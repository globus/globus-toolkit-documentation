<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
<!ENTITY % xinclude SYSTEM "../../../xinclude.mod">
%xinclude;
]>
<book id="wsaajavaDeveloper">
  <title>GT <replaceable role="entity">version</replaceable> Java WS A&amp;A Developer's Guide</title>

  <titleabbrev>Developer's Guide</titleabbrev>

  <bookinfo id="wsaajava-developer-introduction">
    <abstract>
      <title>Introduction</title>

      <para>fixme</para>
    </abstract>
  </bookinfo>

  <chapter id="wsaajava-developer-overview">
    <title>Overview</title>

    <section id="wsaajava-developer-overview-authentication">
      <title>Authentication overview</title>

      <para>Java WS authentication contains mainly framework-level code and,
      as such, developing services and clients utilizing this component does
      in general involve either programmatically or declaratively driving the
      framework-level security code.</para>

      <para>Now, what does this entail? On the programmatic side of things, it
      involves acquiring credentials, passing these credentials on to the
      framework, and setting various authentication- and protection-related
      flags, either in a descriptor or as properties on a stub object. On the
      declarative side, it involves setting up security descriptors, both
      client and service side, to prescribe the security policy used to drive
      the security framework code.</para>
    </section>

    <section id="wsaajava-developer-overview-authorization">
      <title>Authorization framework overview</title>

      <para>The authorization framework enforces the configured authorization
      policy on the service and client side.</para>

      <para>On the service side, the framework allows developers to configure
      a chain of authorization mechanisms either programmatically or
      declaratively using security descriptors. It also allows for plugging in
      new authorization schemes (in addition to using those that are provided
      with the framework). Moreover, the framework allows for this
      configuration to be done at resource, service or container level, each
      taking precedence in the order specified and scoped as the name
      suggests.</para>

      <para>On the client side, a pluggable framework for authorization of
      service is provided.</para>
    </section>
  </chapter>

  <chapter id="wsaajava-developer-beforeyoubegin">
    <title>Before you begin</title>

    <xi:include href="../Java_WS_Security_Feature_Summary_Frag.xml"
                xmlns:xi="http://www.w3.org/2001/XInclude"></xi:include>

    <xi:include href="../Java_WS_Security_Platform_Summary_Frag.xml"
                xmlns:xi="http://www.w3.org/2001/XInclude" />

    <xi:include href="../Java_WS_Security_Compatibility_Summary_Frag.xml"
                xmlns:xi="http://www.w3.org/2001/XInclude" />

    <xi:include href="../Java_WS_Security_Dependencies_Summary_Frag.xml"
                xmlns:xi="http://www.w3.org/2001/XInclude" />

    <xi:include href="../Java_WS_Security_Security_Considerations_Frag.xml"
                xmlns:xi="http://www.w3.org/2001/XInclude" />
  </chapter>

  <chapter id="wsaajava-developer-scenarios">
    <title>Usage scenarios</title>

    <section id="wsaajava-developer-scenarios-delegation">
      <title>Delegation</title>

      <para>There are two ways a client can delegate its credential to a
      service:</para>

      <itemizedlist>
        <listitem>
          <para>using Delegation Service, and</para>
        </listitem>

        <listitem>
          <para>using GSI Secure Conversation.</para>
        </listitem>
      </itemizedlist>

      <para>A client can delegate using the <olink
      targetdoc="delegation">Delegation Service</olink>. This method is
      independent of the security scheme used and can be reused across
      multiple invocations of the client to multiple services (provided the
      services are in the same hosting environment as the Delegation Service).
      The link provided has details on client-side steps to delegate and
      service-side code to get the delegated credential.</para>

      <para>GSI Secure Conversation has delegation built into the protocol.
      Delegation can be requested by setting the <olink targetdoc="wsaajavaPI"
      targetptr="wsaajava-message-domain"><constant>GSIConstants.GSI_MODE</constant></olink>
      property on the Stub or using security descriptors as described in
      <olink targetdoc="wsaajavaDescriptor"
      targetptr="wsaajava-secdesc-client-secConv"></olink>. If full or limited
      delegation is performed, the client credential can be obtained from the
      message context as follows: <screen>Subject subject = (Subject) msgCtx.getProperty(Constants.PEER_SUBJECT);</screen></para>

      <para>The server can be configured such that container, service or
      client credentials are used for the operation invoked. For the client
      credentials to be used, the client should have delegated the
      credentials. Configuring this option is described in <olink
        targetdoc="wsaajavaDescriptor" targetptr="wsaajava-secdesc-service-configRunas"></olink>.
      Note that this is a server-side configuration. If
      <constant>caller-identity</constant> is chosen for the
      <constant>run-as</constant> configuration and the client's credentials
      have been successfully delegated, then the delegated credentials are
      associated with the current thread. The credentials in this case can be
      obtained as follows: <screen>Subject subject = JaasSubject.getCurrentSubject();</screen></para>
    </section>

    <section id="wsaajava-developer-scenarios-keyInfoEPR">
      <title>Embedding Key Information in EPRs</title>

      <para>GT provides an API to embed key information in an Endpoint
      Reference, as defined in the OGSA Basic Security Profile. The key
      information is embedded in the extensibility element of the EPR rather
      than the meta-data element as defined in the specification, since the
      toolkit uses older version of the WS Addressing specification.</para>

      <para>This information would be useful to ascertain the expected
      identity of the service for authorizing the service or to get the public
      certificate of the resource to be used for encrypting the request to the
      service. The optional <computeroutput>usage</computeroutput> element in
      the emebedded key information indicates the use of the embedded keys,
      either for signature or encryption.</para>

      <para>The API is in class
      <constant>org.globus.wsrf.impl.security.util.EPRUtil</constant>. The
      method to embed the certificates is called
      <constant>insertCertificates</constant> and the method to extract the
      key information is called <constant>extractCertificates</constant>.
      Please refer to <olink targetptr="wsaajava-apis">API
      documentation</olink> for details on using the methods.</para>
    </section>

    <section id="wsaajava-developer-scenarios-servicePeerCredentials">
      <title>Obtaining peer credentials on the server side</title>

      <para>The security handlers populate a Subject object with peer
      information. The following code can be used to access the peer
      credentials. Note that the message context needs to be associated with
      the thread. <screen>
          import org.globus.wsrf.security.SecurityManager;
          import javax.security.auth.Subject;
          
          org.apache.axis.MessageContext mctx =
          org.apache.axis.MessageContext.getCurrentContext();
          SecurityManager manager = SecurityManager.getManager(mctx);
          Subject subject = manager.getPeerSubject();
        </screen></para>

      <para>The following code snippet shows how the certificate chain can be
      extracted from the peer subject:<screen>
          java.util.Set set =
          subject.getPublicCredentials(X509Certificate[].class);
          Iterator iterator = set.iterator();
          while (iterator.hasNext()) {
          X509Certificate[] certArray = (X509Certificate[]) iterator.next();
          System.out.println("Cert array " + certArray.length);
          }
        </screen></para>

      <para>To obtain the peer principal (for example, the Distinguished Name
      from X509 Certificate), the following code snippet can be used:<screen>
          org.apache.axis.MessageContext mctx =
          org.apache.axis.MessageContext.getCurrentContext();
          SecurityManager manager = SecurityManager.getManager(mctx);
          Principal principal = manager.getCallerPrincipal();
          String caller = manager.getCaller();
        </screen></para>

      <para>If credentials were delegated as described above, private
      credentials are also populated:<screen>
          java.util.Set set = subject.getPrivateCredentials();
        </screen></para>
    </section>

    <section id="wsaajava-developer-scenarios-clientPeerCredentials">
      <title>Obtaining peer credentials from message context on the client
      side</title>

      <para><itemizedlist>
          <listitem>
            <para><emphasis role="strong">GSI Secure Conversation:</emphasis>
            With this mechanism, the peer credentials can be obtained once the
            handshake is completed:<screen>
                import org.globus.wsrf.impl.security.authentication.Constants;
                import org.globus.wsrf.impl.security.authentication.secureconv.service.SecurityContext;
                import org.ietf.jgss.GSSContext;
                import org.globus.gsi.gssapi.GSSContants;
                
                // Get current secure context from message context 
                SecurityContext secContext = 
                messageContext.getProperty(Constants.CONTEXT);
                GSSContext gssContext = secContext.getContext();
                Vector peerCerts = 
                gssContext.inquireByOid(GSSContants.X509_CERT_CHAIN);
              </screen></para>
          </listitem>

          <listitem>
            <para><emphasis role="strong">GSI Secure Transport:</emphasis>
            With this mechanism, the peer credentials can be obtained once the
            handshake is completed:<screen>
                import org.ietf.jgss.GSSContext;
                import org.globus.gsi.gssapi.GSSContants;
                import org.globus.wsrf.impl.security.authentication.Constants;
                
                // Get current secure context from message context 
                GSSContext gssContext = 
                messageContext.getProperty(Constants.TRANSPORT_SECURITY_CONTEXT);
                Vector peerCerts = 
                gssContext.inquireByOid(GSSContants.X509_CERT_CHAIN);
              </screen></para>
          </listitem>

          <listitem>
            <para><emphasis role="strong">GSI Secure Message:</emphasis> With
            this mechanism, the peer credentials can be obtained only when the
            response is received:<screen>
                import org.globus.wsrf.impl.security.authentication.Constants;
                
                // Get peer subject from current message context
                Subject subject = 
                (Subject) messageCtx.getProperty(Constants.PEER_SUBJECT);
                Set peerCerts = 
                subject.getPublicCredentials(X509Certificate[].class);
              </screen></para>
          </listitem>
        </itemizedlist></para>
    </section>

    <section id="wsaajava-developer-scenarios-samlAssertion">
      <title>Using SAML Authorization Assertions</title>

      <para>SAML Authorization assertions can be used to transport
      authorization decision statements to the point of enforcement. Such
      assertions can be obtained from any entity that manages use rights. For
      example, <olink targetdoc="cas">Community Authorization Service
      (CAS)</olink>, a Globus Toolikit higher level service, can be used to
      manage user rights and issue such assertions. On the remote side,
      PDPs/PIPs might be used to extract the assertion and enforce the rights.
      Some PDPs/PIPs with such functionality are distributed and details can
      be found in <olink targetdoc="wsaajavaPIP"></olink> and <olink
      targetdoc="wsaajavaPDP"></olink>.</para>

      <para>The toolkit provides two mechanisms to do this: <itemizedlist>
          <listitem>
            <para><emphasis role="strong">Using proxy certificates:</emphasis>
            In this mechanism the SAML Authorization Assertions are embedded
            as non-critical assertions in the proxy certificate. These
            assertions can then be extracted from the certificate, to enforce
            access rights at the resource.</para>

            <para>A command line client
            <constant>$GLOBUS_LOCATION/bin/globus-embed-assertion</constant>
            implemented using
            <constant>org.globus.wsrf.client.EmbedAssertion</constant> can be
            used to embed a SAML Assertion stored in a file into a
            credential.</para>
          </listitem>

          <listitem>
            <para><emphasis role="strong">Using SOAP Header:</emphasis> The
            SAML Assertion can also be embedded in the SOAP Header. The
            toolkit uses the WS-Security SAML Token Profile to embed the
            assertion.</para>

            <para><olink targetdoc="wsaajavaDeveloper"
            targetptr="message-interface-domain-syntax"></olink> describes
            the configuration required to embded an assertion into the message
            header. At the remote end, the security handlers detect the
            presence of the SAML Assertion in the header and store it as a
            string in the Message Context property
            <constant>Constants.SAML_ASSERTION_STR.</constant></para>
          </listitem>
        </itemizedlist></para>
    </section>

    <section id="wsaajava-developer-scenarios-multipleMsgProtectionScheme">
      <title>Using Multiple Message Protection Schemes</title>

      <para>Multiple message protection schemes can be used in a single
      invocation, although it is worth noting that this will cause a
      performance penalty.</para>

      <para>For example, both Secure Transport and Secure Conversation can be
      done on the same invocation by using the following:</para>

      <screen>
        stub._setProperty(Constants.GSI_SEC_CONV, Constants.INTEGRITY);
        stub._setProperty(Constants.GSI_TRANSPORT, Constants.PRIVACY);
      </screen>

      <note>
        <para>These two mechanisms share a single property for authorization.
        There is a bug open to provide independent support: <ulink
        url="http://bugzilla.mcs.anl.gov/globus/show_bug.cgi?id=4350">Bug
        4350</ulink></para>
      </note>

      <para>Similarly Secure Messages can be used in tandem with other message
      protection mechanisms.</para>
    </section>

    <section id="wsaajava-developer-scenarios-authz-gums-voms">
      <title>Using GUMS/VOMS for authorization of service access</title>    

      <para> Interceptors have been added to the Globus Toolkit for leveraging authorization services with XACML Authorization Interface, and specifically for using <ulink url="https://www.racf.bnl.gov/Facility/GUMS/1.3/index.html">GUMS</ulink> as the authorization service. Details are provided at <ulink url="http://docs.google.com/Doc?id=dfkt44p2_2frf7n3cq">OSG GUMS/VOMS for WS GRAM AUthorization</ulink></para>
      
      <para> The document describes use of GUMS with VOMS, but GUMS can be used without VOMS and other mapping mechainims can be used. In such cases, the same configuration as described in the above referenced document can be used, without the VOMS interceptors.
      </para>
    </section>

    <section id="wsaajava-developer-scenarios-voms">
      <title>Using VOMS attributes</title>    

      <para><ulink url="http://edg-wp2.web.cern.ch/edg-wp2/security/voms/voms.html">VOMS</ulink> is a grid attribute system that allows a client to embed an attribute certificate in a well known certificate extension. Since the embedded attribute certificate is signed by a VOMS server, a VOMS enabled service can parse and verify this extra certificate and treat the data therein as extra information about the client to use in an authorization decision.</para>

      <para>GT Java web services can consume credentials with VOMS attributes and use the attributes in the authorization descision. Typically a client contacts the VOMS server (using voms-proxy-init) and obtains a credential with VOMS attributes. The proxy with the embedded attributes is then used to contact the GT service.  </para>

      <para>An incubator project, <ulink url="http://dev.globus.org/wiki/Incubator/VOMS">VOMS Authorization Incubator</ulink>, provides the requires PIPs to parse, validate and extract attributes issued by a VOMS server. An overview of provided funcationality is provided <ulink url="http://dev.globus.org/wiki/Incubator/VOMS/Introduction">here</ulink> and the <ulink url="http://dev.globus.org/wiki/Incubator/VOMS/Administrator_Guide">configuration document</ulink> describes using the interceptors.</para>
    </section>
  </chapter>

  <chapter id="wsaajava-developer-tutorials">
    <title>Tutorials</title>

    <para>There are no tutorials available at this time.</para>
  </chapter>

  <chapter id="wsaajava-developer-archdes">
    <title>Architecture and design overview</title>

    <section>
      <title>Authentication/message-level architecture</title>

      <section>
        <title>Transport Security</title>

        <para>The toolkit by default is deployed with our implementation of
        transport security, which is based on HTTP over SSL, also known as
        HTTPS, with modifications to path validation to enable X.509
        <glossterm baseform="proxy certificate">Proxy Certificate</glossterm>
        support. In contrast to the GT3 version of the toolkit, the default
        transport security enabled in the toolkit does not support delegation
        of proxy certificates as part of the security handshake.</para>

        <para>However, the underlying security libraries and handlers required
        for secure transport with delegation, also known as HTTPG, is still
        supported and shipped as part of the CoG library. The GT4 Java WS code
        base and configuration can be modified to use the HTTPG protocol as
        required.</para>

        <para>Transport security is implemented by layering on top of the
        <emphasis>GSISocket</emphasis> class provided in JGlobus. This class
        deals with the security-related aspects of connection establishment as
        well as message protection. The socket interface serves as an
        abstraction layer that allows the HTTP protocol handling code to be
        unaware of the underlying security properties of the
        connection.</para>

        <para>Container-level credentials are required and, irrespective of
        security settings on the service being accessed, these credentials are
        used for the handshake.</para>

        <section>
          <title>Server-Side Security</title>

          <para>On the server-side, transport security is enabled by simply
          switching a non-secure socket implementation with the
          <emphasis>GSISocket</emphasis> implementation. In addition to this
          change, some code was added to propagate authentication information
          and message protection settings to the relevant security handlers,
          in particular the authorization and security policy handlers.</para>
        </section>

        <section>
          <title>Client-Side Security</title>

          <para>On the client-side, transport security is similarly enabled by
          switching a non-secure socket implementation with the
          <emphasis>GSISocket</emphasis> implementation and registering a
          protocol handler for HTTPS that uses the secure socket
          implementation. In practice, this means that any messages targeted
          at an HTTPS endpoint will, irregardless of any stub properties, be
          authenticated and protected. It also means that any messages sent to
          an HTTP endpoint will not be secured, again irregardless of any stub
          properties. Stub properties are only used to communicate the desired
          message protection level, i.e. either integrity only or integrity
          and privacy.</para>
        </section>
      </section>

      <section>
        <title>Message Level Security</title>

        <section>
          <title>Server Side Security</title>

          <para>This section aims to describe the message flow and processing
          that occurs for a security-enabled service. The figure below shows
          the JAX-RPC handlers that are involved in security-related message
          processing on a server.</para>

          <figure id="ServerSideSec">
            <title>The new certificate is signed by the owner, rather than a
            CA.</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="../ServerSideSec-Resized.jpg"
                           format="JPEG" />
              </imageobject>
            </mediaobject>
          </figure>

          <para>GT4 provides two mechanisms, <emphasis role="strong">GSI
          Secure Conversation</emphasis> and <emphasis role="strong">GSI
          Secure Message</emphasis> security, for authentication and secure
          communication.</para>

          <itemizedlist>
            <listitem>
              <para>In the GSI Secure Conversation approach the client
              establishes a context with the server before sending any data.
              This context serves to authenticate the client identity to the
              server and to establish a shared secret using a collocated GSI
              Secure Conversation Service. Once the context establishment is
              complete, the client can securely invoke an operation on the
              service by signing or encrypting outgoing messages using the
              shared secret captured in the context.</para>
            </listitem>

            <listitem>
              <para>The GSI Secure Message approach differs in that no context
              is established before invoking an operation. The client simply
              uses existing keying material, such as an X509 
                <glossterm>End Entity Certificate</glossterm>, to secure messages and
              authenticate itself to the service.</para>
            </listitem>
          </itemizedlist>

          <para>Securing of messages in the GSI Secure Conversation approach,
          i.e. using a shared secret, requires less computational effort than
          using existing keying material in the GSI Secure Message approach.
          This allows the client to trade off the extra step of establishing a
          context to enable more computationally efficient messages protection
          once that context has been established.</para>
        </section>

        <section>
          <title>Message Processing</title>

          <para>When a message arrives from the client, the SOAP engine
          invokes several security-related handlers:</para>

          <para></para>

          <orderedlist>
            <listitem>
              <para>The first of these handlers, the <emphasis
              role="strong">WS-Security handler</emphasis>, searches the
              message for any WS-Security headers. From these headers, it
              extracts any keying material, which can be either in the form of
              an X509 certificate and associated certificate chain or a
              reference to a previously established secure conversation
              session. It also checks any signatures and/or decrypts elements
              in the SOAP body. The handler then populates a peer JAAS subject
              object with principals and any associated keying material whose
              veracity was ascertained during the signature checking or
              decryption step.</para>
            </listitem>

            <listitem>
              <para>The next handler that gets invoked, the <emphasis
              role="strong">security policy handler</emphasis>, checks that
              incoming messages fulfill any security requirements the service
              may have. These requirements are specified, on a per-operation
              basis, as part of a <olink targetdoc="wsaajavaDescriptor">security descriptor</olink> during
              service deployment. The security policy handler will also
              identify the correct JAAS subject to associate with the current
              thread of execution. Generally, this means choosing between the
              peer subject populated by the WS-Security handler, the subject
              associated with the hosting environment and the subject
              associated with the service itself. The actual association is
              done by the pivot handler, a non-security handler not shown in
              the figure that handles the details of delivering the message to
              the service.</para>
            </listitem>

            <listitem>
              <para>The security policy handler is followed by an <emphasis
              role="strong">authorization handler</emphasis>. This handler
              verifies that the principal established by the WS-Security
              handler is authorized to invoke the service. The type of
              authorization that is performed is specified as part of a
              deployment descriptor. More information can be found in the
              <olink targetdoc="wsaajavaDeveloper">authorization framework
              documentation</olink>.</para>
            </listitem>
          </orderedlist>

          <para>Once the message has passed the authorization handler, it is
          finally handed off to the actual service for processing (discounting
          any non-security-related handlers, which are outside the scope of
          this document).</para>

          <para>Replies from the service back to the client are processed by
          two outbound handlers: the GSI Secure Conversation message handler
          and the GSI Secure Message handler. The GSI Secure Conversation
          message handler deals with encrypting and signing messages using a
          previously established security context, whereas the GSI Secure
          Message handler deals with messages by signing or encrypting the
          messages using X509 certificates.</para>

          <para>The operations that are actually performed depend on the
          message properties associated with the message by the inbound
          handlers, i.e. outbound messages will have the same security
          attributes as inbound messages. That being said, a service has the
          option of modifying the message properties, if so desired. These
          handlers are identical to the client-side handlers described in the
          following section.</para>
        </section>

        <section>
          <title>Client Side Security</title>

          <para>This section describes the security-related message processing
          for Java-based GT4 clients. In contrast to the server side, where
          security is specified via deployment descriptors, client side
          security configuration is handled by the application. This means
          that a client-side application must explicitly pass information to
          the client-side handlers on what type of security to use. This is
          also true for the case of services acting as clients. The below
          figure shows the JAX-RPC handlers that are involved in
          security-related message processing on a server.</para>

          <figure id="ClientSideSec">
            <title>JAX-RPC handlers involved in security related message
            processing on a server.</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="../ClientSideSec-Resized.jpg"
                           format="JPEG" />
              </imageobject>
            </mediaobject>
          </figure>
        </section>

        <section>
          <title>Message Processing</title>

          <para>The client-side application can specify the use of either the
          GSI Secure Conversation security approach or the GSI Secure Message
          security approach. It does this by setting a per-message property
          that is processed by the client-side security handlers.</para>

          <para>There are three outbound client-side security handlers:</para>

          <para></para>

          <orderedlist>
            <listitem>
              <para>The <emphasis role="strong">secure conversation service
              handler</emphasis> is only operational if GSI Secure
              Conversation mode is in use. It establishes a security session
              with a secure conversation service collocated with the service
              with which the client aims to communicate. When the client sends
              the initial message to the service with a property indicating
              that session-based security is required, this handler intercepts
              the message and establishes a security session. It will also
              authorize the service by comparing the service's
              principal/subject obtained during session establishment with a
              value provided by the client application. Once the session has
              been established, the handler passes on the original message for
              further processing.</para>
            </listitem>

            <listitem>
              <para>The next handler in the chain, the <emphasis
              role="strong">secure message handler</emphasis>, is only
              operational if GSI Secure Message mode is in use. It signs
              and/or encrypts messages using X.509 credentials.</para>
            </listitem>

            <listitem>
              <para>The third outbound handler [fixme - is there a name?] is
              operational only if GSI Secure Conversation mode is in use. It
              handles signing and/or encryption of messages using a security
              session established by the first handler.</para>
            </listitem>
          </orderedlist>

          <para>The client-side inbound handler (the WS-Security client
          handler) deals with verifying and decrypting any signed and/or
          encrypted incoming messages. In the case of the GSI Secure Message
          operation, it will also authorize the remote side in a similar
          fashion to the outbound secure conversation service handler.</para>
        </section>
      </section>
    </section>

    <section>
      <title>Authorization architecture</title>

      <section>
        <title>Server-side authorization</title>

        <para>The Java WS Authorization framework leverages the generic GT
        Java Authorization Framework. The framework consists of an engine that
        evaluates a chain of configured authorization schemes, also known as
        Policy Decision Points (PDPs), to determine if the client making the
        invocation can access the resource/service. The chain can also be
        configured with Policy Information Points (PIPs), which can be used to
        glean information that would be useful in the decision making
        process.</para>

        <para>A subset of PIPs that collect information only about the
        request i.e. the peer subject, requested action and resource,
        are called Bootstrap PIP. Typically these PIPs are run first
        in the authorization evaluation process, to build the request
        context.</para>

        <para>The framework enables attribute-based authorization. PIPs can be
        used to collect attributes about resource/operations/subjects and used
        in the decision making process. While the toolkit provides some
        implementations of PIPs/PDPs, the framework is pluggable and custom
        mechanisms can be written and configured.</para>

        <para>An authorization engine consists of PIPs, PDPs and a combining
        algorithm. The configured authorization engine is invoked as part of a
        handler chain, immediately after authentication of the invocation
        (<function>java:org.globus.wsrf.impl.security.authorization.AuthorizationHandler</function>).
        If no security mechanism is used for an operation, authorization is
        not done for that operation.</para>

        <para>The architecture of Generic Java Authorization Engine is
        described in detail in this <ulink
        url="../gtJavaAuthzEngine.pdf">document</ulink>. It also describes
        interfaces and writing custom PDPs/PIPs.</para>

        <para>Any PDP has to implement the interface
        <function>org.globus.security.authorization.PDP</function> and contain
        the logic to return a permit or deny based on information such as the
        subject DN, the service being accessed and the operation being
        performed. To manage configuration information, each PDP can be
        bootstrapped with an object implementing the
        <function>org.globus.security.authorization.ChainConfig</function>
        interface. The interface has get and set methods which can be used to
        retrieve and set scoped parameters for the PDP.</para>

        <para>PIPs have to implement the interface
        <function>org.globus.security.authorization.PIP</function> with the
        functionality to collect attributes from the invocation context that
        are relevant to making the authorization decision.</para>

        <section>
          <title>Authorization Policy Configuration</title>

          <para>A chain of PDPs and PIPs, with relevant configuration
          information, can be configured at resource, service or container
          level. These chain use Permit Override with Delegation as default
          combining algorithm. Additionally an administrative policy can be
          configured at the container level. The administrative chain uses
          First Applicable combining algorithm by default. Note that comining
          algorithms can be configured to over-ride the deafult. The following
          describes the precedence in which configured policy is used:</para>

          <para><orderedlist>
              <listitem>
                <para>If container level administrative policy is specified,
                it is evaluated. <orderedlist>
                    <listitem>
                      <para>If (1) returns a deny, the request is
                      denied.</para>
                    </listitem>

                    <listitem>
                      <para>If (1) returns a permit, step (2) is done.</para>
                    </listitem>
                  </orderedlist></para>
              </listitem>

              <listitem>
                <para>If resource level policy is specified, it is evaluated.
                <orderedlist>
                    <listitem>
                      <para>If (2) returns a deny, the request is
                      denied.</para>
                    </listitem>

                    <listitem>
                      <para>If (2) returns a permit, the request is
                      permitted.</para>
                    </listitem>
                  </orderedlist></para>
              </listitem>

              <listitem>
                <para>If (2) is not specified and service level policy is
                specified, it is evaluated. <orderedlist>
                    <listitem>
                      <para>If (3) returns a deny, the request is
                      denied.</para>
                    </listitem>

                    <listitem>
                      <para>If (3) returns a permit, the request is
                      permitted.</para>
                    </listitem>
                  </orderedlist></para>
              </listitem>

              <listitem>
                <para>If (3) is not specified and container level policy
                configuration is specified, it is evalauted. <orderedlist>
                    <listitem>
                      <para>If (4) returns a deny, the request is
                      denied.</para>
                    </listitem>

                    <listitem>
                      <para>If (4) returns a permit, the request is
                      permitted.</para>
                    </listitem>
                  </orderedlist></para>
              </listitem>
            </orderedlist></para>
        </section>

        <section>
          <title>Authorization Handler Steps</title>

          <para><orderedlist>
              <listitem>
                <para>Invoke <olink targetdoc="wsaajavaPIP"
                targetptr="wsaajava-pip-ContainerPIP"></olink> to collect
                attributes inherent to the framework. The PIP creates an
                instance of RequestEntities class to use as parameter with
                PIPs. It also creates an instance of ResourceChainConfig class
                to push the current message context as a parameter to
                ContianerPIP.</para>
              </listitem>

              <listitem>
                <para>Evaluate the administrator authorization engine, if one
                is configured <orderedlist>
                    <listitem>
                      <para>If bootstrap overwrite is configured, then only
                      BootstrapPIPs in administrator engine is invoked. Else
                      the <olink targetdoc="wsaajavaPIP"
                      targetptr="wsaajava-pip-X509Bootstrap"></olink> is
                      invoked prior to any other Bootstrap PIPs
                      configured.</para>
                    </listitem>

                    <listitem>
                      <para>The authorization engine is run and if a deny
                      decision is returned, the operation is denied. If a
                      permit decision is returned, the operation is permitted.
                      If a not applicable or indeterminate is returned,
                      further authorization engines are evaluated.</para>
                    </listitem>
                  </orderedlist></para>
              </listitem>

              <listitem>
                <para>Evaluate the authorization engine configured in the
                resource, service, container, in that order depending on which
                is configured <orderedlist>
                    <listitem>
                      <para>If bootstrap overwrite is configured, then only
                      BootstrapPIPs in administrator engine is invoked. Else
                      the <olink targetdoc="wsaajavaPIP"
                      targetptr="wsaajava-pip-X509Bootstrap"></olink> is
                      invoked prior to any other Bootstrap PIPs
                      configured.</para>
                    </listitem>

                    <listitem>
                      <para>If any decision other than a Permit is returned,
                      the operation is denied. If a permit is returned the
                      operation is allowed.</para>
                    </listitem>
                  </orderedlist></para>
              </listitem>

              <listitem>
                <para>If no authorization engine was configured, then default
                authorization engine is created, which checks whether the
                caller has same credentials as service (self
                authorization)</para>
              </listitem>
            </orderedlist></para>
        </section>
      </section>

      <section>
        <title>Client-side authorization</title>

        <para>Client side authorization is done as a part of the
        authentication handler. GSI Secure Message authentication does
        client-side authorization only after the operation is completed. This
        is done as a part of the web services client handler. The other two
        authentication schemes supported, GSI Secure Conversation and GSI
        Transport, authorize the server during the handshake, prior to the
        operation invocation.</para>

        <para>The Transport Level Security protocol allows for authorization
        (an expected DN comparison) during the handshake. This is disabled by
        default in the toolkit, unless delegation of credential is requested.
        If no delegation is requested, the configured authorization mechanism
        is invoked afer the handshake is complete, prior to the operation
        invocation. If delegation is requested, authorization (expected DN
        comparison) is done during key exchange as a part of the
        protocol.</para>

        <para>The toolkit supports self, gridmap, host and identity
        authorization on the client side. The authorization to be used is set
        programmatically on the Stub and the handler enforces it.</para>
      </section>
    </section>
  </chapter>

  <xi:include href="../Java_WS_Security_Interface_API_Frag.xml"
              xmlns:xi="http://www.w3.org/2001/XInclude"></xi:include>

  <xi:include href="../Java_WS_Security_Interface_WSDL_Frag.xml"
              xmlns:xi="http://www.w3.org/2001/XInclude"></xi:include>

  <xi:include href="../Java_WS_Security_Interface_Protocol_Frag.xml"
              xmlns:xi="http://www.w3.org/2001/XInclude"></xi:include>

  <!-- 
  <reference id="wsaajava-developer-cmd"><title>Command-line tools</title>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
      href="../Java_WS_Security_Interface_Commandline_Frag.xml"/>
  </reference>

  <chapter id="wsaajava-developer-guis"><title>Graphical User Interfaces</title>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
      href="../Java_WS_Security_Interface_GUI_Frag.xml"/>
  </chapter>
  -->

  <xi:include href="../Java_WS_Security_Interface_Domain_Message_Frag.xml"
              xmlns:xi="http://www.w3.org/2001/XInclude"></xi:include>

  <xi:include href="../Java_WS_Security_Interface_Domain_Authz_Frag.xml"
              xmlns:xi="http://www.w3.org/2001/XInclude"></xi:include>

  <!-- fixme: does the following frag overlap the two domain frags (which talk about configuration a lot) -->

  <xi:include href="../Java_WS_Security_Interface_Config_Frag.xml"
              xmlns:xi="http://www.w3.org/2001/XInclude"></xi:include>

  <chapter id="wsaajava-developer-env">
    <title>Environment variable interface</title>

    <xi:include href="../Java_WS_Security_Interface_Env_Frag.xml"
                xmlns:xi="http://www.w3.org/2001/XInclude"></xi:include>
  </chapter>

  <chapter id="wsaajava-pdp-pip-links">
  <title>PDP/PIP Links</title>
  <para>The following are links to PDPs and PIPs included in GT <replaceable role="entity">version</replaceable>:
  <itemizedlist>
    <listitem><para><olink targetdoc="wsaajavaPDP"/></para></listitem>
    <listitem><para><olink targetdoc="wsaajavaPIP"/></para></listitem>
  </itemizedlist>
    
  </para>
</chapter>
  
  <chapter id="wsaajava-developer-debugging">
    <title>Debugging</title>

    <!-- fixme - need to double-check all info for authz and message are represented here -->

    <para>Because Java WS A&amp;A is built on top of Java WS Core, developer
    debugging is the same as described in <olink
    targetdoc="javawscoreDeveloper"
    targetptr="javawscore-developer-debugging"></olink>.</para>

    <para>For information about system administrator logs, see <olink
    targetdoc="wsaajavaAdmin"
    targetptr="wsaajava-admin-debugging"></olink>.</para>

    <para>Java WS Core also provides an API for CEDPs-compliant logging as
    described in <olink targetdoc="javawscoreAdmin"
    targetptr="javawscore-logging-cedps"></olink>.</para>

    <section>
      <title>Debugging authorization</title>

      <para>Log output from the authorization framework is a useful tool for
      debugging issues. Because the Authorization Framework is built on top of
      Java WS Core, developer debugging is the same as described in <olink
      targetdoc="javawscoreDeveloper"
      targetptr="javawscore-developer-debugging"></olink>.</para>

      <xi:include href="../../../common/javawscore/Java_WS_Core_Logging_Frag.xml"
                  xmlns:xi="http://www.w3.org/2001/XInclude"
                  xpointer="javawscore-developer-logging-general"></xi:include>

      <section>
        <title>Enabling verbose logging</title>

        <para>As described in the above section, configuration files need to
        be edited to enable logging at different levels. For example, to see
        all logging for server side authorization, the following lines need to
        be added to container logging configuration file. To see client-side
        authorization framework logging, the same line needs to be added to
        <emphasis>$GLOBUS_LOCATION/log4j.properties</emphasis>.<screen>log4j.category.org.globus.wsrf.impl.security.authorization=DEBUG </screen></para>

        <para>The authorization module uses <ulink
        url="http://www.globus.org/cog/java/">Java CoG Kit</ulink> for some of
        the functionality. To turn on logging for that functionality, the
        following can be added to the relevant logging file, depending on
        whether it is the client or the server side logging.<screen>log4j.category.org.globus.gsi.jaas=DEBUG
log4j.category.org.globus.gsi.gssapi=DEBUG
log4j.category.org.globus.security.gridmap=DEBUG</screen></para>
      </section>
    </section>
  </chapter>

  <chapter id="wsaajava-developer-troubleshooting">
    <title>Troubleshooting</title>

    <para>For a list of common errors in GT, see <olink targetdoc="gtuser"
    targetptr="errors"></olink>.</para>

    <xi:include href="../Java_WS_Security_Errors_Frag.xml"
                xmlns:xi="http://www.w3.org/2001/XInclude"></xi:include>
  </chapter>

  <chapter id="wsaajava-developer-relateddocs">
    <title>Related Documentation</title>

    <simpara>See <olink targetdoc="wsaajavaRN"
    targetptr="wsaajava-associatedstandards"></olink> for a list of associated
    standards.</simpara>
  </chapter>

  <glossary id="glossary-wsaajavaDeveloper" role="auto">
    <!-- 
    <remark>some terms not in the docs but wanted in glossary: 
    <glossterm>scheduler</glossterm>
    </remark>
    -->

    <glossdiv>
      <title>A</title>

      <glossentry>
        <glossterm>Dummy term</glossterm>

        <glossdef>
          <para>This is a dummy entry for the automatic glossary database. Do
          not edit.</para>
        </glossdef>
      </glossentry>
    </glossdiv>
  </glossary>
</book>