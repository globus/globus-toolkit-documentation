<?php

$title = "Core: Developer's Guide";

include_once( "/mcs/www-unix.globus.org/include/globus_header.inc" ); 
?>


<p class="small"><a href="http://www.globus.org">Globus</a> &gt;

<a href="http://www-unix.globus.org/toolkit/">Toolkit</a> &gt;

<a href="http://www-unix.globus.org/toolkit/docs/">Documentation</a> &gt; <a href="../../index.html">3.2</a> &gt; <a href="../index.html">Core</a> &gt; Developer's
Guide
&lt; </p>

<h1>Core: Developer's Guide </h1>
<p class="small"> <a href="index.html">Overview </a><br>
    <a href="http://www-unix.globus.org/toolkit/3.2/core/javadocs">APIs </a><br>
  &gt;Programmer's Guide <br>
      <a href="performance.html">Performance Guide </a><br>
      <a href="javacodingguidelines.html">Java Coding Guidelines </a><br>
      <a href="securitysupport.html">Security Support </a><br>
      <a href="test_framework.html">Test
Framework</a></p>
<h2>Java Programming Guide</h2>
<p>This page contains the following topics: </p>
<ul>
  <li><a href="#Introduction">Introduction</a></li>
  <li><a href="#Introduction">    </a> <a href="#WritingService">Writing
    a Service </a></li>
  <li><a href="#WritingService">    </a> <a href="#WritingClient">Writing a Client </a></li>
  <li><a href="#WritingClient">                      </a> <a href="#TestService">Testing the Service</a></li>
  <li><a href="#TestService">                                                              </a> <a href="#ServiceData">Service Data </a></li>
  <li><a href="#ServiceData">                                                                                                                                                      </a> <a href="#Notifications">Notifications </a></li>
  <li><a href="#Notifications">                                                                                                                                                                                                                                                                                                                                                                                                                                              </a> <a href="#ServiceProperties">Service Properties and Configuration </a></li>
  <li><a href="#ServiceProperties">                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </a> <a href="#ServiceActivation">Service Activation, Deactivation,
  and Recovery Framework </a></li>
  <li>    <a href="#CustomFactory">Writing a Custom Factory </a></li>
  <li>    <a href="#PerformanceProfiling">Performance Profiling </a></li>
  <li>    <a href="#ServiceContainer">Service Container </a></li>
  <li><a href="#ServiceContainer">                                                                                                                      </a><a href="#XPath">XPath Queries </a></li>
  <li><a href="#XPath">                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      </a><a href="#WSIF">WSIF Client <br>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </a></li>
</ul>
<h2><a name="Introduction"></a>Introduction </h2>
<p>This document is a guide to Programming with Grid services in Java. It covers
  both client- and server-side programming, and it focuses on explaining example
  code and use cases. It does not provide a complete reference to all of the
  APIs. Please refer to the javadocs for this information. The guide only covers
  the core framework, for more information on EJB, security, and higher-level
  services (such as Managed Job Service, Reliable File Transfer Service, and
  Index Service) support see separate documentation. For installation, deployment,
  and development environment documentation see the <a href="../../installation/">Installation
  Guide</a>. </p>
<p>This guide is structured into two parts. The first part, <em>Getting Started </em>,
  describes how to write, deploy, and access a simple Grid service in the framework.
  The second part, <em>Additional APIs </em>, describes some additional APIs
  and features provided by our framework for more advanced service development. </p>
<p>Basic knowledge of Java and Ant ( <a href="http://jakarta.apache.org/ant">http://jakarta.apache.org/ant </a>)
  is assumed in this guide. We also assume that you are familiar with the basic
  OGSA environment. </p>
<h1>Part I: Getting Started </h1>
<h2><a name="WritingService"></a>1 Writing a Service </h2>
<p>The following steps are involved in writing a Grid service: </p>
<ul>
  <li>
    <p><strong>Step 1. Provide a Service Interface </strong></p>
  <li>
    <p><strong>Step 2. Generate Grid Service Support Code </strong></p>
  <li>
    <p><strong>Step 3. Implement the Service </strong></p>
  <li>
    <p><strong>Step 4. Deploy the Service </strong></p>
  </li>
</ul>
<p>The complete source code for this example is available in the guide directory
  in your framework distribution. </p>
<h3>Step 1. Provide a Service Interface </h3>
<p>There are two approaches to providing an interface for your service that is
  to be exposed to remote clients. You can either write the interface in java,
  and generate the WSDL interface, or you can provide the interface using a WSDL
  port type definition. We will look closer at the two approaches next. </p>
<p><strong>Java Interface </strong></p>
<p>We define the following Java interface:&nbsp; </p>
<pre class="command">
 package org.globus.ogsa.guide.impl.guide; 
 
 public interface Counter { 
 	public int add(int value); 
	public int subtract(int value); 
	public int getValue(); 
}
</pre>
<p>See guide/src/org/globus/ogsa/guide/impl/Counter.java for the full example. </p>
<p>This approach should be used with care because some complex java types do
  not map very well into WSDL and could thus impair the interoperability of your
  service. It is however useful if you want to expose legacy code written in
  Java as Grid services, without requiring any programmatic effort. </p>
<p><strong>WSDL PortType Interface </strong></p>
<p>When providing a WSDL interface you only need to provide the abstract definition
  of the service including the types, message, and portType parts of WSDL. The
  binding, and service part will be generated for you by our tools. This approach
  may at first glance look more complicated and verbose than the <em>Java Interface </em>approach.
  But the more complicated your service gets the likelier it is that you will
  come across types and constructs in Java that don't have a clear mapping to
  XML. Defining the interface in WSDL also makes it easier to reuse designs in
  a language neutral way. Someone might for instance write a Grid service in
  C, and define a set of types for that service in XML Schema. Using the <em>WSDL
  PortType Interface </em> approach will make it very easy to embed all these
  types and even extend the interfaces from this service in your new service
  to be developed in Java.&nbsp; </p>
<p>Note in the example below that we define port types in the gwsdl namespace,
  this is done to circumvent the fact that WSDL 1.1 does not allow portType inheritance
  nor embedded extensions. WSDL 1.2, however, does allow these constructs, and
  when that specification is released and the OGSI specification is fully based
  on it, the gwsdl namespace will go away and be replaced by the wsdl 1.2 namespace. </p>
<p>Here are some excerpts from the wsdl definition: </p>
<pre class="command">&lt;types&gt;
...
&lt;xsd:element name=&quot;add&quot;&gt;
&nbsp; &lt;xsd:complexType&gt;
&nbsp;&nbsp;&nbsp; &lt;xsd:sequence&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xsd:element name=&quot;value&quot; type=&quot;xsd:int&quot;/&gt;
&nbsp;&nbsp;&nbsp; &lt;/xsd:sequence&gt;&nbsp;
&nbsp; &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;
...
&lt;/types&gt;
...
&lt;message name=&quot;AddInputMessage&quot;&gt;
&nbsp; &lt;part name=&quot;parameters&quot; element=&quot;tns:add&quot;/&gt;
&lt;/message&gt;
...
&lt;gwsdl:portType name=&quot;CounterPortType&quot; extends=&quot;ogsi:GridService&quot;&gt;
&nbsp; &lt;operation name=&quot;add&quot;&gt;
&nbsp;&nbsp;&nbsp; &lt;input message=&quot;tns:AddInputMessage&quot;/&gt;
&nbsp;&nbsp;&nbsp; &lt;output message=&quot;tns:AddOutputMessage&quot;/&gt;
&nbsp;&nbsp;&nbsp; &lt;fault name=&quot;Fault&quot; message=&quot;ogsi:FaultMessage&quot;/&gt;
&nbsp; &lt;/operation&gt;
&lt;/gwsdl:portType&gt;</pre>
<p>The types section defines the add operation to have one parameter called value
  of type int. The message section ties the input message to the concrete xml
  element to be used as payload of the operation. Finally the portType section
  defines that this portType should also expose all the operations defined in
  the ogsi:GridService portType. Also note that the standard ogsi fault can be
  thrown from this operation, which is good practice to declare even if you don't
  have any application specific faults. </p>
<p>See guide/schema/counter_port_type.gwsdl for the full example </p>
<p>To produce a complete wsdl 1.1 definition&nbsp; from this gwsdl port type
  definition you would need to run it through the GWSDL2WSDL, and generateBinding&nbsp; tools
  as follows: </p>
<pre class="command">&lt;ant antfile=&quot;${build.services}&quot; target=&quot;GWSDL2WSDL&quot;&gt;
&nbsp; &lt;property name=&quot;build.schema.dir&quot; value=&quot;guide/Counter&quot;/&gt;
&nbsp; &lt;property name=&quot;wsdl.root&quot; value=&quot;counter_port_type&quot;/&gt;&nbsp;
 &lt;/ant&gt;
 &lt;ant antfile=&quot;${build.services}&quot; target=&quot;generateBinding&quot;&gt;
&nbsp; &lt;property name=&quot;binding.root&quot; value=&quot;counter&quot;/&gt;
&nbsp; &lt;property name=&quot;build.schema.dir&quot; value=&quot;guide/Counter&quot;/&gt;
&nbsp; &lt;property name=&quot;porttype.wsdl&quot; value=&quot;counter_port_type.wsdl&quot;/&gt;
 &lt;/ant&gt;&nbsp;</pre>
<p>GWSDL2WSDL creates a WSDL 1.1 portType containing all the operations inherited
  from the gwsdl definition. The generateBinding tool generates the wsdl:binding
  and wsdl:service parts for the portType definition. Currently we only support
  doc/literal SOAP 1.1 bindings. </p>
<h3>Step 2. Generate Grid Service Support Code </h3>
<p>We provide high level ant task and xml batch file based tools to simplify
  the generation of the required stub and support code for hosting your service
  as an OGSI compliant Grid service. Although you may not use these tools directly,
  all the tools are centered around two tools primitives generateWSDL and generateStubs,
  which are used to generate WSDL from a Java interface and Java stubs for a
  WSDL interface respectively. However in order to understand better how the
  higher level tools work we first briefly explain these two basic tools. For
  the best tools support we recommend that you use the GWSDL2WSDL, generateBinding,
  and generateStubs primitives when generating a service from a WSDL file. However,
  if you start from a java interface we recommend that you use the higher level
  bottomUp tool described below. The generateWSDL tool is described below for
  completeness. </p>
<p><strong>Generate WSDL from Java </strong></p>
<p>An existing Java interface can be run through a Java to WSDL tool using the
  following ant command: </p>
<pre class="command">&lt;ant antfile=&quot;${build.services}&quot; target=&quot;generateWSDL&quot;&gt;
  &lt;property name=&quot;interface.package&quot; value=&quot;org.globus.ogsa.guide.impl&quot;/&gt;
  &lt;property name=&quot;interface.name&quot; value=&quot;Counter&quot;/&gt;
  &lt;property name=&quot;generated.dir&quot; value=&quot;guide&quot;/&gt;
&lt;/ant&gt;</pre>
<p>See guide/build.xml for the full example. </p>
<p>Note that the ${build.services} property has to point to the location of build-services.xml
  shipped with the framework. This command will generate a WSDL file and populate
  it with a binding supporting the required GridService PortType. </p>
<p><strong>Generate Stubs form WSDL <br>
  </strong>After you have obtained a WSDL interface either by generating it from
  a java interface or from a wsdl portType definition (Step 2 above), the next
  step is to generate Java stubs to handle all the serialization/deserialization
  of your data to/from XML. </p>
<pre class="command">&lt;ant antfile=&quot;${build.services}&quot; target=&quot;generateStubs&quot;&gt;
  &lt;property name=&quot;schema.file.dir&quot; value=&quot;guide/Counter&quot;/&gt;
<span style="mso-spacerun: yes"> </span><span style="mso-spacerun: yes"> </span>&lt;property name=&quot;schema.file&quot; value=&quot;counter_service.wsdl&quot;/&gt;
&lt;/ant&gt;&nbsp;<o:p></pre>
<p>See guide/build.xml for the full example. </p>
<p>This command will generate the JAX-RPC compliant interfaces to be used both
  on the client and on the server side. Client side stub implementations of these
  interfaces will also be generated. </p>
<p><strong>Bottom Up vs Top Down </strong></p>
<p align="center"><img height="429" src="../../../images/bottomup_topdown.jpg" width="547"></p>
<p>We provide two higher level tools based on these primitives called <em>Bottom
    Up </em> and <em>Top Down </em>. Bottom Up refers to an approach when you
    start out from a legacy java application and want to generate a Grid service
    layer on top of it. Top Down refers to an approach when you either get the
    WSDL from an implementation in another environment or standards community,
    or you write the WSDL yourself, and want to generate the java mapping for
    this interface. For a detailed tutorial with examples of how to use these
    tools please see the <a href="http://www-unix.globus.org/toolkit/3.0/ogsa/docs/tools_guide.html">Tools Guide </a>. Note that
    if you use these high level tools you can skip step 3 and 4 below. It is
    all generated for you. </p>
<h3>Step 3. Implement the Service </h3>
<p><strong>Inheritance Approach </strong></p>
<pre class="command">public class CounterImpl extends GridServiceImpl implements CounterPortType {
    private int val = 0;

    public CounterImpl() {
        super(&quot;Guide Counter&quot;);
    }
    public int add(int val) throws RemoteException {
        this.val = this.val + val;
        return this.val;
    }
    public int subtract(int val) throws RemoteException {
        this.val = this.val - val;
        return this.val;
    }
    public int getValue() throws RemoteException {
        return this.val;
    }
}</pre>
<p>See guide/src/org/globus/ogsa/guide/impl/CounterImpl.java and guide/src/org/globus/ogsa/guide/impl/WSDLCounterImpl.java
  for the full examples of implementations of the <em>Java Interface </em>approach
  and the <em>WSDL PortType Interface </em> approach respectively. Note the only
  thing that differs between the two implementations is the namespace from where
  you pick up the generated counter interface to implement. </p>
<p>Note that the CounterPortType is the endpoint interface generated in the previous
  step. All remotely available operations must be public and throw java.rmi.RemoteException
  as defined in the PortType interface. The GridServiceImpl class may be inherited
  from. It is provided by our framework and implements the OGSI defined GridService
  interface, along with other core Grid service behavior. <br>
    <strong>If your service inherits from GridServiceImpl and overrides any of
    the standard GridServiceCallback methods such as <em>postCreate(), activate(),
    deactivate(), </em> and <em>preDestroy() </em> always make sure to invoke
    the super method of the overridden method, e.g. in your <em>postCreate() </em> implementation
    make sure to call <em>super.postCreate() </em>. </strong></p>
<p><strong>Operation Providers <br>
  </strong>If you do not want any code to depend on implementation classes in
  our container you can also implement the service using the operation provider
  (aka delegation) approach. This design makes it easy to plug in various implementations
  of wsdl operations at deployment time. As reference points, the OGSI defined
  NotificationSource and Factory interfaces have been implemented as operation
  providers in our framework. So to add in factory, or notification behavior
  to your service you only need to change the deployment descriptor of your service
  (described in more detail in the next section). <br>
    <br>
Below is the counter example above implemented as an operation provider: 
<pre class="command">public class CounterProvider implements OperationProvider, GridServiceCallback {
    // Use the double wild card with care - all operations not in the OGSI 
    // namespace will be delegated to this class by default
    private static final QName[] operations = new QName[]{new QName(&quot;&quot;, &quot;*&quot;)};
    private GridServiceBase base;
    private int val = 0;

    // Operation Provider methods
    public void initialize(GridServiceBase base) throws GridServiceException {
        this.base = base;
    }
    public QName[] getOperations() {
        return operations;
    }
    // Counter PortType methods
    public int add(int val) throws RemoteException {
        this.val = this.val + val;
        return this.val;
    }
    public int subtract(int val) throws RemoteException {
        this.val = this.val - val;
        return this.val;
    }
    public int getValue() throws RemoteException {
        return this.val;
    }
    // GridServiceCallback methods (optional)
    public void preCreate(GridServiceBase base) throws GridServiceException {
    }
    public void postCreate(GridContext context) throws GridServiceException {
    }
    public void activate(GridContext context) throws GridServiceException {
    }
    public void deactivate(GridContext context) throws GridServiceException {
    }
    public void preDestroy(GridContext context) throws GridServiceException {
    }
}</pre>
<p>A provider needs to specify all the operation QNames (namespace and local
  name as defined in wsdl) to implement. Note that we allow the wildcard '*'
  to be used to specify that all operations from a certain namespace are implemented.
  An empty string namespace means that operations in all namaspaces apart from
  the built-in OGSI namespace are implemented. These operations need to be returned
  in a getOperations() callback. The Provider also needs to provide an implementation
  of the initialize method which is used to bootstrap the provider and to associate
  it with a GridServiceBase. The GridServiceBase object is an implementation
  of the core Grid service behaviors. GridServiceImpl in the previous example
  is an example of a GridServiceBase implementation.&nbsp; </p>
<p>See guide/src/org/globus/ogsa/guide/impl/CounterProvider.java for the complete
  example. </p>
<h3>Step 4. Deploy the Service </h3>
<p>This step consists of three sub tasks 1) write a deployment descriptor configuring
  your service, and 2) create a gar package of the configuration along with your
  implementation, 3) deploy the gar package into a Grid service hosting environment </p>
<p>1) Write a deployment descriptor </p>
<pre class="command">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;deployment name=&quot;defaultServerConfig&quot; xmlns=&quot;<a href="http://xml.apache.org/axis/wsdd/">http://xml.apache.org/axis/wsdd/</a>&quot; xmlns:java=&quot;http://xml.apache.org/axis/wsdd/providers/java&quot;&gt;&nbsp;<o:p>
</o:p>  &lt;service name=&quot;guide/counter/CounterProviderFactoryService&quot; provider=&quot;Handler&quot; style=&quot;wrapped&quot;&gt;
  &lt;parameter name=&quot;name&quot; value=&quot;Guide Counter Provider Factory&quot;/&gt;
  &lt;parameter name=&quot;instance-name&quot; value=&quot;Guide Counter Proivider Counter&quot;/&gt;
  &lt;parameter name=&quot;instance-schemaPath&quot; value=&quot;schema/guide/Counter/counter_service.wsdl&quot;/&gt;
  &lt;parameter name=&quot;instance-className&quot; value=&quot;org.globus.ogsa.guide.Counter.wsdl.CounterPortType&quot;/&gt;
  &lt;parameter name=&quot;instance-baseClassName&quot; value=&quot;org.globus.ogsa.impl.ogsi.GridServiceImpl&quot;/&gt;
  &lt;parameter name=&quot;instance-operationProviders&quot; value=&quot;org.globus.ogsa.guide.impl.CounterProvider&quot;/&gt;
  &lt;parameter name=&quot;persistent&quot; value=&quot;true&quot;/&gt;
  &lt;parameter name=&quot;schemaPath&quot; value=&quot;schema/ogsi/ogsi_notification_factory_service.wsdl&quot;/&gt;
  &lt;parameter name=&quot;baseClassName&quot; value=&quot;org.globus.ogsa.impl.ogsi.PersistentGridServiceImpl&quot;/&gt;
  &lt;parameter name=&quot;handlerClass&quot; value=&quot;org.globus.ogsa.handlers.RPCURIProvider&quot;/&gt;
  &lt;parameter name=&quot;className&quot; value=&quot;org.gridforum.ogsi.NotificationFactory&quot;/&gt;
  &lt;parameter name=&quot;allowedMethods&quot; value=&quot;*&quot;/&gt;
  &lt;parameter name=&quot;factoryCallback&quot; value=&quot;org.globus.ogsa.impl.ogsi.DynamicFactoryCallbackImpl&quot;/&gt;
  &lt;parameter name=&quot;operationProviders&quot; value=&quot;org.globus.ogsa.impl.ogsi.FactoryProvider org.globus.ogsa.impl.ogsi.NotificationSourceProvider&quot;/&gt;
 &lt;/service
&lt;/deployment&gt;</pre>
<p>See guide/guide-config.wsdd for the complete example. </p>
<p>Here is a more detailed description of the various parts of the deployment
  descriptor: </p>
<p>(parameters prefixed with "instance-" concern instances created by a factory,
  other parameters belong to the factory configuration)&nbsp; </p>
<p>&nbsp;Note that for factories almost all the non-instance scoped parameters
  are boiler-plate configuration and will be the same for most of your factories. </p>
<table cellspacing="0" cellpadding="0">
  <tr>
    <td valign="top" width="295"><p>&lt;service name=xxx…. </p></td>
    <td valign="top" width="295"><p>This is where you define the remotely accessible
        name for your service. Your service factory URL will have the form of &lt;hosting
        environment URL&gt;/xxx, where hosting environment URL typically is <a href="http://%3chost%3e:%3cport%3e/ogsa/services">http://&lt;host&gt;:&lt;port&gt;/ogsa/services </a></p></td>
  </tr>
  <tr>
    <td valign="top" width="295"><p>&lt;parameter name=”name”… </p></td>
    <td valign="top" width="295"><p>The human readable description of this service
        to be exposed to e.g.&nbsp; admin clients (optional) </p></td>
  </tr>
  <tr>
    <td valign="top" width="295"><p>&lt;parameter name=”className”… </p></td>
    <td valign="top" width="295"><p>The className parameter specifies a class
        or an interface that has public methods corresponding to all wsdl operations. <strong>Note
        that all the operations available in operation providers and base implementations
        must be exposed in this class or interface. </strong></p></td>
  </tr>
  <tr>
    <td valign="top" width="295"><p>&lt;parameter name=”baseClassName”… </p></td>
    <td valign="top" width="295"><p>The baseClassName parameter specifies what
        class implements this service. If it is the same as className it can
        be left out.(optional) </p></td>
  </tr>
  <tr>
    <td valign="top" width="295"><p>&lt;parameter name=”operationProviders”… </p></td>
    <td valign="top" width="295"><p>The list of classes that are to be loaded
        into this service as operation providers. The list items are separated
        by spaces. The order of the providers is the order in which they will
        be initialized. (optional) </p></td>
  </tr>
  <tr>
    <td valign="top" width="295"><p>&lt;parameter name=”persistent”… </p></td>
    <td valign="top" width="295"><p>This sets the Grid service apart from other
        web services you may have configured in your hosting environment. If
        this flag is not present your service will be treated as a regular Web
        service. </p></td>
  </tr>
  <tr>
    <td valign="top" width="295"><p>&lt;parameter name=”schemaPath”…. </p></td>
    <td valign="top" width="295"><p>This variable points the framework to a place
        where a template WSDL description of the service exists (in this case
        the standard factory description provided by the framework) </p></td>
  </tr>
  <tr>
    <td valign="top" width="295"><p>&lt;parameter name=”instance-schemaPath”…. </p></td>
    <td valign="top" width="295"><p>In case you are deploying a factory like
        in this example you need to set the instance-schemaPath to a location
        describing the interface of the service that the factory can create.
        In our case this wsdl description was generated in step 1 above </p></td>
  </tr>
  <tr>
    <td valign="top" width="295"><p>&lt;parameter name=”handlerClass”… </p></td>
    <td valign="top" width="295"><p>This configuration specifies what dispatcher
        to use on the server side. The default one we provide in our framework
        dispatches into the local hosting environment based on the URI of the
        incoming request and is called org.globus.ogsa.handlers.RPCURIProvider </p></td>
  </tr>
  <tr>
    <td valign="top" width="295"><p>&lt;parameter name=”factoryCallback”… </p></td>
    <td valign="top" width="295"><p>This parameter points to a class that implements
        the FactoryCallback interface used to create service instances. </p></td>
  </tr>
</table>
<p>2) Package your configuration, schemas and code into a gar package </p>
<pre class="command">&lt;ant antfile=&quot;${build.packages}&quot; target=&quot;makeGar&quot;&gt;
&nbsp; &lt;property name=&quot;gar.name&quot; value=&quot;${build.lib}/guide.gar&quot;/&gt;
&nbsp; &lt;property name=&quot;garlib.dir&quot; value=&quot;${build.lib}&quot;/&gt;
&nbsp; &lt;property name=&quot;garserverdeployment.file&quot; value=&quot;guide-config.wsdd&quot;/&gt;
&nbsp; &lt;property name=&quot;garschema.origin&quot; value=&quot;${build.schema}/guide&quot;/&gt;
&nbsp; &lt;property name=&quot;garschema.path&quot; value=&quot;guide&quot;/&gt;
&lt;/ant&gt;</pre>
<p>See guide/build.xml for the full example. </p>
<p>This sample ant task packages the code (which we assumed you have compiled,
  e.g with the ant javac target or manually, see full example in the distribution
  for details). The garserverdeployment.file property points to the deployment
  descriptor file provided in the previous step. </p>
<p>3) Deploy the gar package into a Grid service Hosting Environment </p>
<p>In the distribution directory of your ogsa installation make the following
  command line call: ant deploy –Dgar.name=&lt;path to gar created in previous
  step&gt; <br>
  To deploy the samples in this guide type <em><strong>ant deployGuide </strong></em>. </p>
<h2><a name="WritingClient"></a>Writing a Client </h2>
<p>The standard JAX-RPC interfaces can be used to access a Grid service. However,
  for convenience, since JAX-RPC currently has no knowledge of GSRs or GSHs we
  provide some extensions to simplify access to a Grid service. </p>
<h3>JAX-RPC Example </h3>
<blockquote>
  <pre class="command">OGSIServiceLocator factoryLocator = new OGSIServiceLocator();
Factory factory = factoryLocator.getFactoryPort(new URL(url));
GridServiceFactory gridFactory = new GridServiceFactory(factory);
LocatorType locator = gridFactory.createService();
...&nbsp;<o:p> </o:p>
CounterServiceLocator counterLocator = new CounterServiceLocator();
CounterPortType counter = counterLocator.getCounterPort(new URL(instanceUrl));
int val = counter.add(2);&nbsp;<o:p> </o:p></pre>
  <p>The problem with this approach is that there is no easy way of feeding the
    GSR that the factory returns into the instance proxy generation, to make sure
    you are accessing the service you just created. Note the GridServiceFactory
    is a wrapper utility we provide to simplify invocations on OGSI factories. </p>
</blockquote>
<h3>Extended JAX-RPC Example </h3>
<blockquote>
  <pre class="command">OGSIServiceGridLocator gridLocator = new OGSIServiceGridLocator();
Factory factory = gridLocator.getFactoryPort(handle);
GridServiceFactory gridFactory = new GridServiceFactory(factory);
LocatorType locator = gridFactory.createService();
CounterServiceGridLocator counterLocator =<span style="mso-spacerun: yes">&nbsp;&nbsp; </span>new CounterServiceGridLocator();
CounterPortType counter = counterLocator.getCounterPort(locator);
int val = counter.add(2);&nbsp;<o:p> </o:p></pre>
  <p>See guide/src/org/globus/ogsa/guide/impl/CounterClient.java for the full example. </p>
  <p>Note that the &lt;service&gt;GridLocator is also generated from the WSDL definition
    of the service together with the standard JAX-RPC ServiceLocator, so it does
    not involve any extra effort for a programmer to use this approach. The GridLocator
    is able to do OGSI based handle to reference resolution, and accepts both an
    OGSI Handle and an OGSI Locator (returned from a factory creation)&nbsp; as
    input to the proxy creation. </p>
</blockquote>
<h2><a name="TestService"></a>Testing the Service </h2>
<h3><strong>Command Line Client </strong></h3>
<ol>
  <ol>
    <li>Make sure you have started a grid service container e.g. using <em><strong>globus-start-container </strong></em>
    </li>
    <li>Create service instance using <em><strong>ogsi-create-service &lt;server
          url&gt;/&lt;sample factory service name&gt; |id| </strong></em>. The &lt;id&gt; is
          used to distinguish between instances you create under the same factory,
          and may be omitted in which case the server generates this id. The &lt;server
          url&gt; is typically http://&lt;host&gt;:&lt;port&gt;/ogsa/services.
          The &lt;sample factory service name&gt; must be the same name as defined
          in server-config.wsdd. <br>
      Example: <em><strong>ogsi-create-service <a href="http://127.0.0.1:8080/ogsa/services/guide/counter/CounterFactoryService?WSDL">http://localhost:8080/ogsa/services/guide/counter/CounterFactoryService </a> calc </strong></em>
    </li>
    <li>Run your command line client created as described in section 2, giving
      it the URL of the endpoint returned by the <em><strong>ogsi-create-service </strong></em> call
      (make sure your environment is set properly using the <a href="../../developer/commonclients.html#Environment">setenv
      scripts </a>. <br>
      Example: <em><strong> java org.globus.ogsa.guide.impl.CounterClient <a href="http://127.0.0.1:8080/ogsa/services/guide/counter/CounterFactoryService/calc">http://localhost:8080/ogsa/services/guide/counter/CounterFactoryService/calc </a> add
    10 </strong></em></li>
  </ol>
</ol>
<h3><strong>GUI client </strong></h3>
<blockquote>
  <p>If you want to test your service in the ServiceBrowser GUI framework you
    would have to provide a GUI panel implementation for your service port type(s).
    See org/globus/ogsa/gui/CounterPortTypePanel in the ogsa distribution samples
    for an example. You would also need to add a mapping to your panel in the &lt;ogsa
    root&gt;/client-gui-config.xml file.&nbsp; </p>
  <p>To test your GUI client:
  </p>
  <ol>
    <li>Start the gui client by typing <em><strong>globus-service-browser </strong></em>
    </li>
    <li>Locate your factory in the Service Group Entry Inspection panel, and
      double click on its entry </li>
    <li>Create an instance in the Factory panel and now your custom Panel should
            be displayed if all goes well </li>
  </ol>
</blockquote>
<h1>PART II: Additional APIs </h1>
<p>This section describes some features and APIs available to Grid service developers. </p>
<p>Some APIs are divided into client and server side APIs. Note that client or
  server is a role played by a runtime component, and does not necessarily translate
  into a client process or server process, i.e. the communication is peer-to-peer,
  and anyone can act as either a client or a server. </p>
<h2><a name="ServiceData"></a>Service Data </h2>
<p>The core framework populates all Grid services with service data mandated
  by the Grid service specification. What service data you get in your service,
  hence depends on what Grid service PortTypes you implement. As an extension
  to the specification, we also allow you to expose the ServiceGroup, and NotificationSource
  service data in your factories (using the respective operation providers in
  your deployment descriptor) to make it easy to introspect and monitor the instances
  created by a factory. If you would like to add your own service data, in addition
  to the standard service data set, we provide an API to do so. We allow you
  to write an XML Schema type definition for your service data. You could then
  optionally generate a Java bean from the definition, or treat it as an XML
  Infoset (like DOM). Both the Bean and DOM can be used to populate your service
  data set at runtime. We also allow you to specify the service data in Java
  through annotations, without having to write an XML Schema definition, which
  will be discussed in section 4.2.1. </p>
<h3>Sample XML Schema Definition </h3>
<blockquote>
  <pre class="command">&lt;complexType name=&quot;CounterStateType&quot;&gt;
    &lt;sequence&gt;
      &lt;element name=&quot;value&quot; type=&quot;int&quot;/&gt;
      &lt;element name=&quot;status&quot; type=&quot;string&quot;/&gt;
    &lt;/sequence&gt; 
    &lt;attribute name=&quot;timestamp&quot; type=&quot;dateTime&quot;/&gt;
  &lt;/complexType&gt;</pre>
  <p>See guide/schema/counter_state.xsd for the full example. </p>
  <p>This XML Schema fragment provides a definition of a Service Data Element.
    Note that the complex type must have one single root element. This element
    may however have many child elements. </p>
</blockquote>
<h3>Server APIs </h3>
<blockquote>
  <pre class="command">public class ServiceDataCounterImpl extends GridServiceImpl
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; implements CounterPortType {
&nbsp;&nbsp;&nbsp; private int val = 0;
    private ServiceData stateData;
    private CounterStateType state = new CounterStateType();

    public ServiceDataCounterImpl() {
        super(&quot;Guide Service Data Counter&quot;);
    }

    public void postCreate(GridContext context) throws GridServiceException {
        super.postCreate(context);
        stateData = serviceData.create(&quot;CounterState&quot;);
        updateState();
        stateData.setValue(this.state);
        serviceData.add(stateData);
    }

    private void updateState() {
        state.setStatus(....);
        state.setTimestamp(Calendar.getInstance());
        state.setValue(this.val);
    }

    public int add(int val) throws RemoteException {
        this.val = this.val + val;
        updateState();
        return this.val;
    }
}</pre>
    <p>See guide/src/org/globus/ogsa/guide/impl/ServiceDataCounterImpl.java for the
    full example. </p>
    <p>The service data element defined in the previous step is run through the
        stub generator as described in section 1, step 2. This results in a Bean
        (CounterStateType) that can be used when adding custom service data to
        your service. The ServiceDataSet interface (serviceData instance)&nbsp; is
        used to create, and add service data to the service data collection of
        a service. The ServiceData API provides a wrapper API for all service data.
        You can either set an arbitrary value using the setValue()/addValue() API
        or provide a value callback (not shown). The ServiceData object should
        be seen as a logical collection of service data values conforming to a
        serviceData declaration in WSDL. ServiceData added in this manner will
        automatically be made available to findServiceData queries on the service
        after the call serviceData.add() has been made. Note that the above example
        uses the inheritance approach fro implementing a service in which case
        the service data set will be available in the instance variable called
        serviceData. If you implement your service using the operation provider
        approach, the service data will be available by calling getServiceDataSet()
      on the GridServiceBase object passed in to to initialize callback. </p>
    <p>The service data set&nbsp; population is performed in a postCreate callback
        (see section 7 for details) to ensure that the framework has initialized
      the service data before any operation is called. </p>
    <p>To test this example do the following: </p>
    <p>1. <strong><em>java org.globus.ogsa.client.CreateService <a href="http://127.0.0.1:8080/ogsa/services/guide/counter/ServiceDataCounterFactoryService?WSDL">http://localhost:8080/ogsa/services/guide/counter/ServiceDataCounterFactoryService </a> calc <br>
  </em></strong>2 . <em><strong>java org.globus.ogsa.guide.impl.CounterClient <a href="http://127.0.0.1:8080/ogsa/services/guide/counter/ServiceDataCounterFactoryService/calc">http://localhost:8080/ogsa/services/guide/counter/ServiceDataCounterFactoryService/calc </a> state </strong></em></p>
</blockquote>
<h3>Service Data Annotations</h3>
<blockquote>
  <p><strong>  </strong>You can expose service data automatically by adding an
    @ogsa:service-data tag to the javadoc comment of a method that returns the
    service data.&nbsp; The
    method must be accessible through the public service, it must be part of the
    port type interface.&nbsp;&nbsp; </p>
  <p>For example:
  </p>
  <pre class="command">/**
* The current value of the counter.
* @ogsa:service-data
*/
public int getValue() throws RemoteException {
&nbsp;&nbsp;&nbsp; return val;
}</pre>
  <p>@ogsa:service-data can be followed by optional parameters that will go in
    the generated wsd <br>
      <br>
    The parameters with their default values are: </p>
</blockquote>
<table>
  <tr>
    <td width="10%">name&nbsp;&nbsp;&nbsp;&nbsp; </td>
    <td width="90%">name of the method (without "get" if those are the first
      3 letters, and without the last s if the method returns an array) </td>
  </tr>
  <tr>
    <td width="10%">minOccurs </td>
    <td width="90%">1 (0 if the method returns an array) </td>
  </tr>
  <tr>
    <td width="10%">maxOccurs </td>
    <td width="90%">1 ("unbounded" if the method returns an array) </td>
  </tr>
  <tr>
    <td width="10%">mutability </td>
    <td width="90%">"mutable" </td>
  </tr>
</table>
<blockquote>
  <pre class="command">/**
* The current value of the counter.
* @ogsa:service-data
*&nbsp;&nbsp;&nbsp;&nbsp; name = &quot;currentValue&quot;
*&nbsp;&nbsp;&nbsp;&nbsp; minOccurs = &quot;1&quot;
*&nbsp;&nbsp;&nbsp;&nbsp; maxOccurs = &quot;1&quot;
*&nbsp;&nbsp;&nbsp;&nbsp; mutability = &quot;mutable&quot;
*/
public int getValue() throws RemoteException {
&nbsp;&nbsp;&nbsp; return val;
}</pre>
  <p>Then you generate the wsdl by calling two ant targets in build-services.xml 
  </p>
  <pre class="command">&lt;ant antfile=&quot;${build.services}&quot; target=&quot;serviceDataDoclet&quot;&gt;
&nbsp; &lt;property name=&quot;service.source&quot; value=&quot;${src.dir}/org/globus/ogsa/guide/impl/ServiceDataAnnotationCounterImpl.java&quot;/&gt;
&nbsp; &lt;property name=&quot;dest.dir&quot; value=&quot;${build.dest}&quot;/&gt;
&lt;/ant&gt;</pre>
  <pre class="command">&lt;ant antfile=&quot;${build.services}&quot; target=&quot;generateSDD&quot;&gt;
&nbsp;&nbsp; &lt;property name=&quot;service.name&quot; value=&quot;org.globus.ogsa.guide.impl.ServiceDataAnnotationCounterImpl&quot;/&gt;
&nbsp;&nbsp;&nbsp;&nbsp; &lt;property name=&quot;wsdl.dir&quot; value=&quot;guide/TimedCounter&quot;/&gt;
 &nbsp;&nbsp;&nbsp; &lt;property name=&quot;wsdl.file&quot; value=&quot;TimedCounterService.wsdl&quot;/&gt;
 &nbsp;&nbsp;&nbsp; &lt;property name=&quot;wsdl.file&quot; value=&quot;TimedCounterService.wsdl&quot;/&gt;
&lt;/ant&gt;</pre>
  <p>The method that exposes the service data will automatically be called whenever
    someone queries for the service data. <br>
    See guide/src/org/globus/ogsa/guide/impl/ServiceDataAnnotationCounterImpl.java
    for the full example. <br>
    To test the example do the following: <br>
    1. <em><strong>java org.globus.ogsa.client.CreateService <a href="http://127.0.0.1:8080/ogsa/services/guide/counter/ServiceDataAnnotationCounterFactoryService?WSDL">http://localhost:8080/ogsa/services/guide/counter/ServiceDataAnnotationCounterFactoryService </a> annotcalc&nbsp; </strong></em><br>
    2. <em><strong>java org.globus.ogsa.guide.impl.CounterClient <a href="http://127.0.0.1:8080/ogsa/services/guide/counter/ServiceDataAnnotationCounterFactoryService/annotcalc?WSDL">http://localhost:8080/ogsa/services/guide/counter/ServiceDataAnnotationCounterFactoryService/annotcalc </a> add
    5&nbsp; <br>
    </strong></em>3. <strong><em>java org.globus.ogsa.client.FindServiceDataByName
    currentValue <a href="http://127.0.0.1:8080/ogsa/services/guide/counter/ServiceDataAnnotationCounterFactoryService/annotcalc?WSDL">http://localhost:8080/ogsa/services/guide/counter/ServiceDataAnnotationCounterFactoryService/annotcalc </a></em></strong><br>
    4. <strong><em>java org.globus.ogsa.client.FindServiceDataByName timestamp <a href="http://127.0.0.1:8080/ogsa/services/guide/counter/ServiceDataAnnotationCounterFactoryService/annotcalc?WSDL">http://localhost:8080/ogsa/services/guide/counter/ServiceDataAnnotationCounterFactoryService/annotcalc </a></em></strong></p>
</blockquote>
<h3>Client APIs </h3>
<blockquote>
  <pre class="command">OGSIServiceGridLocator locator = new OGSIServiceGridLocator();
GridService gridService =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; locator.getGridServicePort(handle);

ExtensibilityType extensibility = gridService.findServiceData(QueryHelper.getNamesQuery(&quot;CounterState&quot;));
ServiceDataValuesType serviceData = AnyHelper.getAsServiceDataValues(extensibility);
CounterStateType counterState = (CounterStateType) AnyHelper.getAsSingleObject(serviceData, CounterStateType.class);
System.out.println(&quot;Counter state:&quot;);
System.out.println(&quot;    status:&quot; + counterState.getStatus());
System.out.println(&quot;    val:&quot; + counterState.getValue());
System.out.println(&quot;    timestamp:&quot; + counterState.getTimestamp().getTime());</pre>
    <p>See guide/src/org/globus/ogsa/guide/impl/CounterClient.java for the full example. </p>
    <p>The GridService interface can be used to query service data for a service.
      The QueryHelper is used to construct a valid findServiceData query (in this
      case a OGSI compliant byServiceDataNames query). The query result can contain
      any arbitrary element, but in this case (as defined by OGSI) we know that it
      will return a ServiceDataValuesType containing our CounterState of type CounterStateType.
      Note, that because we know what kind of value is contained in the ServiceDataValuesType
      we can tell the AnyHelper API how to deserialize the object by passing the
      class of the object we are expecting. If no class is specified the typemapping
    registry (see next section) is used to determine how to deserialize the object. </p>
</blockquote>
<h3>TypeMappings for Custom Types </h3>
<blockquote>
    <p>If you put custom types in your service data, as opposed to basic types
      like xsd:string, you will need to make the AnyHelper aware of what types
      you expect.&nbsp; The
    easiest way of doing this is to pass in the type of the class you want to convert
    the any object to in the getAsObject() calls. If you do not know the type of
    the any object at compile time, you will need to add a typemapping declaration
    to the deployment descriptor.&nbsp;Below follows an example of a type mapping
    that you can add to your service. For full details please see the <a href="http://cvs.apache.org/viewcvs.cgi/~checkout~/xml-axis/java/docs/reference.html#Deployment">Axis
    deployment descriptor documentation</a>. </p>
  <pre class="command">&lt;typeMapping xmlns:ns=&quot;http://www.example.org&quot;
             qname=&quot;ns:MyType&quot;
             type=&quot;java:org.example.MyType&quot;
             serializer=&quot;org.apache.axis.encoding.ser.BeanSerializerFactory&quot;
             deserializer=&quot;org.apache.axis.encoding.ser.BeanDeserializerFactory&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
             encodingStyle=&quot;&quot;/&gt;</pre>
</blockquote>
<h2><a name="Notifications"></a>Notifications </h2>
<h3>Server APIs </h3>
<blockquote>
  <p>To enable notifications of service data in your server you have to specify
      NotificationSourceProvider as an operationsProvider in your deployment
    descriptor. Further,&nbsp; the className, and the schemaPath interfaces will
    have to expose the Notification Source operations. The easiest way of achieving
    this is to extend from the NotificationSource portType in your gwsdl definition.
    See guide/schema/notification_counter_port_type.gwsdl. Now a notification
    is sent out to all subscribers of your service data whenever you call notifyChange()
    on your ServiceData wrapper. (Complete source can be found in guide/src/org/globus/ogsa/guide/impl/NotificationCounterImpl.java) </p>
</blockquote>
<h3>Client APIs </h3>
<blockquote>
  <p>In order to receive notifications from services a client will have to act
    as a service itself. To make it easy to expose notification sinks in lightweight
    clients we provide a NotificationSinkManager API. It is in essence a wrapper
    around a ServiceContainer (see section 10). </p>
  <p>Here is an example of how to subscribe to a source: </p>
  <pre class="command">NotificationSinkManager manager = NotificationSinkManager.getManager();

manager.startListening(NotificationSinkManager.MAIN_THREAD);

String sink  =&nbsp; manager.addListener(&quot;CounterStatus&quot;, timeout, source, callback);&nbsp;<o:p> </o:p></pre>
  <p>When adding a listener you specify the service data name you want to subscribe
    to, the timeout of the subscription (if null infinite timeout is set), the
    handle of the service containing the service data, and a callback where notifications
    will be sent. The callback must implement the NotificationSinkCallback interface. </p>
  <p>Here is an example of a NotificationSink callback implementation: </p>
  <pre class="command">public void deliverNotification(ExtensibilityType any)
<span style="mso-spacerun: yes">&nbsp; </span>throws RemoteException {
<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>try {
<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;    </span>ServiceDataValuesType serviceData = AnyHelper.getAsServiceDataValues(any);
        String counterStatus = (String) AnyHelper.getAsSingleObject(serviceData);
        System.out.println(&quot;Counter status:&quot; + counterStatus)
<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>} catch (Exception e) {
<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>e.printStackTrace();
<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>}
}</pre>
  <p>See guide/src/org/globus/ogsa/guide/impl/StatusListener.java for the full
    example. <br>
    To test this example do the following: </p>
  <p>1. <strong><em>java org.globus.ogsa.client.CreateService <a href="http://127.0.0.1:8080/ogsa/services/guide/counter/NotificationCounterFactoryService?WSDL">http://localhost:8080/ogsa/services/guide/counter/NotificationCounterFactoryService </a>&nbsp; calc <br>
    </em></strong>2. in a new window start: <em><strong> java org.globus.ogsa.guide.impl.StatusListener <a href="http://127.0.0.1:8080/ogsa/services/guide/counter/NotificationCounterFactoryService/calc?WSDL">http://localhost:8080/ogsa/services/guide/counter/NotificationCounterFactoryService/calc </a><br>
    </strong></em>3. <em><strong>java org.globus.ogsa.guide.impl.CounterClient <a href="http://127.0.0.1:8080/ogsa/services/guide/counter/NotificationCounterFactoryService/calc?WSDL">http://localhost:8080/ogsa/services/guide/counter/NotificationCounterFactoryService/calc </a>&nbsp; add
    1 <br>
  </strong></em></p>
  <p>Start up a new window and run: </p>
  <p class="command">java org.globus.ogsa.guide.impl.StatusListener </p>
</blockquote>
<h2><a name="ServiceProperties"></a>Service Properties and Configuration </h2>
<p>ServiceProperties are used in a similar way to ServiceData by a service to
  hold Grid service instance specific state. The main difference is that ServiceProperties
  are internal to the service, i.e. they are not automatically exposed to clients,
  and they do not have to be specified in an XML Schema.&nbsp; The ServiceProperties
  interface, allows you to set and get arbitrary (potentially persistent) properties,
  keyed on strings. The interface is defined as follows: </p>
<pre class="command">package org.globus.ogsa;

public interface ServiceProperties {
&nbsp; public Object getProperty(String name);&nbsp;
&nbsp; public void setProperty(String name, Object obj);&nbsp;
&nbsp; public Object getPersistentProperty(String name);&nbsp;
&nbsp; public void setPersistentProperty(String name, Object obj);&nbsp;
&nbsp; public void flush() throws ServicePropertiesException;&nbsp;
};</pre>
<p>The GridServiceImpl base class implements the ServiceProperties interfaces,
  and they can hence be used by all Grid services. Persistent property support
  must however be turned on in the configuration to enable checkpointing, see
  next section. The framework also uses the service properties API to set service
  specific context information and configuration. For instance, all the configuration
  parameters defined in your deployment descriptor will be made available through
  this API. Note that in the case of factories you configure your instance properties
  with the "instance-" prefix. These properties will then be automatically be
  made available to the instances through thair ServiceProperties interface.&nbsp;&nbsp; </p>
<p>To access configuration global to a container, you can use the ContainerConfig
  API, like this: </p>
<pre class="command">import org.globus.ogsa.config.ContainerConfig;
...
String globalOption = ContainerConfig.getConfig().getOption(&quot;myGlobalOption&quot;);</pre>
<p>All configuration put inside of&nbsp; the globalConfiguration section in the
  deployment descriptor is made available through this API. </p>
<h2><a name="ServiceActivation"></a>Service Activation, Deactivation, and Recovery
  Framework </h2>
<p>Our container supports activation, deactivation, and recovery from restarts
  of service instances. The framework makes sure that these server side transitions
  are completely transparent to a client of the service in terms of all state
  required to support the Grid service behavior (i.e. Grid service specification
  required SDEs are always logically available to clients). If you maintain your
  own state outside of the framework that you would like to maintain in a similar
  way you can implement this behavior in framework provided callbacks. The interface
  below can optionally be implemented by operation providers, and factory callbacks.
  If you use the inheritance approach and extend the GridServiceImpl class you
  will automatically get these callbacks, but you would need to make sure that
  you don't disable the default implementation, which is why we recommend implementing
  these callbacks in operation providers where you don't have that problem. </p>
<pre class="command">package org.globus.ogsa;

public interface GridServiceCallback  {
&nbsp; public void postCreate(GridContext context) throws GridServiceException;&nbsp;
&nbsp; public void activate(GridContext context) throws GridServiceException;&nbsp;
  public void deactivate(GridContext context) throws GridServiceException;&nbsp;
&nbsp; public void preDestroy(GridContext context) throws GridServiceException;
}</pre>
<p>The postCreate callback is guaranteed to be called when the framework has
  finished populating the service instance with all environment and configuration
  properties, and optionally recovered persistent state for recoverable services.
  Activate and deactivate can be used to checkpoint or squirrel away state that
  is not needed when the service is idle. The framework provides default activators
  and deactivators that can be configured or even replaced&nbsp; by your own
  policy implementation. All services deployed into a container are in a deactivated
  state by default, and then get activated on first use. By default the services
  will never be deactivated, but a TTL policy can be configured to let idle services
  time out into deactivated state. A lifecycle monitor interceptor interface
  can be used to monitor state transitions, it is for instance used by the default
  deactivator: </p>
<pre class="command">package org.globus.ogsa;

public interface ServiceLifecycleMonitor {
&nbsp; public void create(GridContext context) throws GridServiceException;&nbsp;
&nbsp; public void preCall(GridContext context) throws GridServiceException;&nbsp;
&nbsp; public void postCall(GridContext context) throws GridServiceException;&nbsp;
&nbsp; public void destroy(GridContext context) throws GridServiceException;&nbsp;
}</pre>
<p>A life cycle monitor can be configured for all services listed in a deployment
  descriptor. It is however typically configured for factories to monitor its
  instances. Here is an example of such a configuration: </p>
<pre class="command">&lt;service name=&quot;samples/counter/deactivation/CounterFactoryService&quot; provider=&quot;Handler&quot; style=&quot;wrapped&quot;&gt;
&nbsp; &lt;parameter name=&quot;allowedMethods&quot; value=&quot;*&quot;/&gt;
&nbsp; &lt;parameter name=&quot;className&quot; value=&quot;org.globus.ogsa.impl.samples.counter.basic.CounterFactoryImpl&quot;/&gt;
&nbsp; &lt;parameter name=&quot;persistent&quot; value=&quot;true&quot;/&gt;
&nbsp; &lt;parameter name=&quot;schemaPath&quot; value=&quot;schema/core/factory/factory_service.wsdl&quot;/&gt;
&nbsp; &lt;parameter name=&quot;instance-schemaPath&quot; value=&quot;schema/samples/counter/counter_service.wsdl&quot;/&gt;
&nbsp; &lt;parameter name=&quot;handlerClass&quot; value=&quot;org.globus.ogsa.handlers.RPCURIProvider&quot;/&gt;
&nbsp; &lt;parameter name=&quot;lifecycleMonitorClass&quot; value=&quot;org.globus.ogsa.repository.DefaultServiceDeactivator&quot;/&gt;
&nbsp; &lt;parameter name=&quot;instance-deactivation&quot; value=&quot;10000&quot;/&gt; &lt;!-- idle
TTL before deactivation in milliseconds--&gt;
 &lt;/service&gt;</pre>
<p>Apart from the DefaultServiceDeactivator we also provide a Performance Logger
  implementation (see section 9) of the ServiceLifecycleMonitor interface used
  to instrument services. </p>
<p>Finally, to tell the framework that you want to allow the service instances
  to be recoverable, and in order to use the persistent property APIs described
  above you need to add the following parameter to your deployment descriptor: </p>
<pre class="command">&lt;parameter name="instance-lifecycle" value="persistent"/&gt; </pre>
<h2><a name="CustomFactory"></a>Writing a Custom Factory </h2>
<p>If the default dynamic factory implementation is not flexible enough, you
  can write your own factory implementation. The custom factory can be used to
  virtualize a service in another hosting environment, or it can be implemented
  to create many different implementations depending on creation input and/or
  configuration and run time settings. You could also provide a factory callback
  to provide implementations for the GridServiceCallback methods descried above.
  Implementing the GridServiceCallback is however optional in a factory. The
  only required interface that&nbsp; you have to implement is the FactoryCallback
  interface. </p>
<p>Here is an example of how one would implement a factory for the counter example
  demonstrated in section 1: </p>
<pre class="command">package org.globus.ogsa.guide.impl;

import org.globus.ogsa.FactoryCallback;
import org.globus.ogsa.GridServiceBase;
import org.globus.ogsa.GridServiceException;
import org.gridforum.ogsi.ExtensibilityType;

public class CounterFactoryCallback implements FactoryCallback {
    public void initialize(GridServiceBase base) throws GridServiceException {
    }
    public GridServiceBase createServiceObject(ExtensibilityType extension) 
            throws GridServiceException {
        return new CounterImpl();
    }
}</pre>
<p>Then you would need to change your deployment descriptor to make the factoryCallback
  parameter point to this class. </p>
<h2><a name="PerformanceProfiling"></a>Performance Profiling </h2>
<p>There is a pluggable performance logger that you can use to instrument your
  code. the only thing required to use the logger is to set the following parameter
in your factory deployment descriptor: 
<pre class="command">&lt;parameter name=&quot;lifecycleMonitorClass&quot; value=&quot;org.globus.ogsa.handlers.PerformanceLifecycleHandler&quot;/&gt;</pre>
<p>In order to turn on and off various levels of instrumentation (everything
  is turned off by default) you need to modify your log4j.properties files. Here
  is an example: </p>
<pre class="command">log4j.category.org.globus.ogsa.performance.samples.any.AnyFactoryService=DEBUG</pre>
<p>This entry enables the debug filter for the factory configured with service
  name "samples/any/AnyFactoryService". </p>
<p>To do application specific instrumentation you can use the PerformanceLog
  API like this: </p>
<pre class="command">import org.globus.ogsa.utils.PerformanceLog;
...
PerformanceLog performanceLogger = new PerformanceLog(MyClass.class.getName() + &quot;.performance&quot;);
...
performanceLogger.start();
callMyOp();
performanceLogger.stop(&quot;callMyOp&quot;);</pre>
<p>The performance logger is thread safe in that the start() and stop() only
  concerns the local thread. <br>
    <br>
  The logs are now enabled using the following configuration: </p>
<pre class="command">log4j.category.MyClass.performance=DEBUG </pre>
<h2><a name="ServiceContainer"></a>Service Container </h2>
<p>A service container API is provided to start embedded local hosting environments
  listening on particular ports. The current embedded hosting environment support
  the httpg and the http protocols. All services that can run inside of a standalone
  service container or a servlet engine, can also be run in a embedded mode.
  The NotificationSinkManager API described in section 5 makes use of this API
  to multiplex all sink URLs exposed over a single port (per transport). Our
  test framework also makes use of this API to transparently run all unit tests
  against both a standalone/tomcat server and an embedded server. </p>
<p>Here is an example: </p>
<pre class="command">import org.globus.ogsa.server.ServiceContainer;
...
boolean isMainThread = false;
int port = 8080; // if 0 or omitted get available port from TCP stack
ServiceContainer container = ServiceContainer.createContainer(isMainThread, port);
container.waitForInit();
// now we have entered event loop
container.waitForStop();
// now server has shutdown<o:p></pre>
<h2><a name="XPath"></a>XPath Queries </h2>
<p>We now have experimental support for XPath queries on service data. See <a href="../../infosvcs/ws/developer/xpath.html">full
    documentation </a>. </p>
<h2><a name="WSIF"></a>WSIF Clients </h2>
<p>The <a href="http://ws.apache.org/wsif/">Web Service Invocation Framework
    (WSIF)&nbsp; </a> is a client side run rime environment and API for invoking
    Web services when not all parts of the WSDL definition is known at compile
    time. This allows for two things 1) the WSDL binding section and thus the
    transport mechanism of the request can change at run time 2) the provider
    used to implement the transport can change at run time. From an OGSI point
    of view we are most interested in 1), because it is a scenario anticipated
    by the GSH to GSR refresh model. We provide a simple WSIF client example
    that demonstrate the client API you need to use to get this dynamic behavior.
    Note that we still only support the SOAP/HTTP transport although a JMS version
    has been worked on. We also provide an extension to WSIF that takes advantage
    of the dynamic type mapping of comples types in Axis. So if you use Axis
    for the transport implementation, you don't need to set up any type mappings
    for complex types manually. Here is the simple example: </p>
<pre class="command">WSIFServiceFactory factory = WSIFServiceFactory.newInstance();
WSIFService service =  factory.getService(args[1], null, null, GUIDE_NS, &quot;ComplexCounterPortType&quot;);
WSIFUtils.registerMappings(service, ComplexCounterPortType.class);

ComplexCounterPortType counter =  (ComplexCounterPortType) service.getStub(ComplexCounterPortType.class);
TimestampedValue timestampedValue = new TimestampedValue();
timestampedValue.setTime(Calendar.getInstance());
timestampedValue.setValue(Integer.parseInt(args[0]));

int val = counter.submitAction(ActionType.add, timestampedValue);</pre>
<p>See guide/src/org/globus/ogsa/guide/impl/WSIFCounterClient.java for the full
  example. </p>
<p>To test this example do the following: </p>
<p>1. <em><strong>java org.globus.ogsa.client.CreateService <a href="http://127.0.0.1:8080/ogsa/services/guide/counter/ComplexCounterFactoryService?WSDL">http://localhost:8080/ogsa/services/guide/counter/ComplexCounterFactoryService </a>&nbsp; calc <br>
  </strong></em>2. <em><strong>java org.globus.ogsa.guide.impl.WSIFCounterClient
  10 <a href="http://127.0.0.1:8080/ogsa/services/guide/counter/ComplexCounterFactoryService/calc?WSDL">http://localhost:8080/ogsa/services/guide/counter/ComplexCounterFactoryService/calc?WSDL </a></strong></em><em><strong><br>
  </strong></em></p>
<p>&nbsp;</p>
<?php include("http://www-unix.globus.org/include/globus_footer.inc"); ?>